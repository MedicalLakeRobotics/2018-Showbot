// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// PHS: port from C++ complete (not tested yet)

package org.usfirst.frc4513.Showbot.subsystems;

import org.usfirst.frc4513.Showbot.RobotMap;
import org.usfirst.frc4513.Showbot.commands.*;
import com.ctre.CANTalon;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;

import edu.wpi.first.wpilibj.command.Subsystem;

import edu.wpi.first.wpilibj.SerialPort;


/**
 *
 */
public class Drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon rearRightSpdCtr = RobotMap.drivetrainRearRightSpdCtr;
    private final CANTalon rearLeftSpdCtr = RobotMap.drivetrainRearLeftSpdCtr;
    private final CANTalon frontRightSpdCtr = RobotMap.drivetrainFrontRightSpdCtr;
    private final CANTalon frontLeftSpdCtr = RobotMap.drivetrainFrontLeftSpdCtr;
    private final RobotDrive robotDrive41 = RobotMap.drivetrainRobotDrive41;
    private final Encoder leftDriveEncoder = RobotMap.drivetrainLeftDriveEncoder;
    private final Encoder rightDriveEncoder = RobotMap.drivetrainRightDriveEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // PHS: added these member vars based on .h file
    // PHSNOTE: AHRS.h is not in the project given to me, so must be some external library
    //    Appears to be navX-MXP, so installed their java library
	private AHRS ahrs;
	private PowerDistributionPanel pdp; 
	
	private final float TWISTTHROTTLEMOD=1.25f;			//reserves memory for variable/attribute TWISTTHROTTLEMOD which is a constant
	private final float XYDEADBAND=0.1f;				//reserves memory for variable/attribute XYDEADBAND which is a constant
	private float 		TWISTDEADBAND=0.025f;			//reserves memory for variable/attribute TWISTDEADBAND which is a constant
	private float throttle, yValue, twistValue, xValue;	// joystick working variable
	
	public double MotorLeft;			// tank drive
	public double MotorRight;			// tank drive
	public double MotorSpeed;			// arcade drive
	public double MotorAngle;			// arcade drive
	public double MotorMode;			// arcade = 0, tank = 1

	double JoyXaxis, JoyYaxis, JoyTwist, JoyThrottle, JoyReverse;
	
	// PHS: Added this constructor to get all the vars initialized similar to how it was done in C++
	//      See concerns about this approach in CompressorSubSys
	//      All these variable inits can actually be done without a constructor if this is a problem
	//      Weird that I had to import SerialPort manually (Eclipse wouldn't suggest it)
	//      Note the added dereference to get to kMXP
	public Drivetrain() {
		ahrs = new AHRS(SerialPort.Port.kMXP);
		pdp = new PowerDistributionPanel();

	    // ------- Initialize variables to zero ---------------------
	    MotorLeft = MotorRight = MotorSpeed = MotorAngle = MotorMode = 0;
	  	JoyXaxis = JoyYaxis = JoyTwist = JoyThrottle = JoyReverse=0;
	   	throttle = yValue = twistValue = xValue = 0;

	   	robotDrive41.setSafetyEnabled(false);	// possibly remove this line may not be needed		
	}

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveByJoystickCmd());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // PHS: added these based on .cpp file - left the commented out code in C++ syntax
    public void stopMtrs()	{
    	frontLeftSpdCtr.set(0);
    	frontRightSpdCtr.set(0);
    	rearLeftSpdCtr.set(0);
    	rearRightSpdCtr.set(0);
    }

    // PHS: guessing that the shared_ptr mess is not applicable to Java
    public void driveByJoystick(Joystick joy) {

    	double speedx, speedy, joyThrottle, throttlex, throttley;
    	// throttlex=0.75;
    	// throttley=0.75;
    	joyThrottle= ((joy.getThrottle()-1)/-2);					// converts range to 0 to +1
    	throttlex = joyThrottle;
    	throttley = joyThrottle;
    	speedx=joy.getTwist() * throttlex;
    	// PHSPROBLEM: Is this correct, or should it perhaps be: -joy.getTwist*throttley
    	speedy=joy.getY() * throttley;
    	robotDrive41.arcadeDrive(speedy, speedx);

    	/*
    	JoyXaxis = joy->GetX();
    	JoyYaxis = joy->GetY();
    	JoyTwist = joy->GetTwist();
    	JoyThrottle = joy->GetThrottle();
    	JoyReverse = 0;

//    	if (joy->GetRawButton(11) == true){
//    		JoyYaxis = JoyYaxis * -1;	// reverse direction
//    		JoyReverse = 1;
//    	}
    	throttle=JoyThrottle;								// put throttle value into variable Throttle
    	throttle=((throttle-1)/-2);							// converts range to 0 to +1
    	yValue=JoyYaxis;									// sets y value of joystick to variable YValue

    	if(((yValue) <= (XYDEADBAND * throttle)) &&
    	   ((yValue) >= - (XYDEADBAND * throttle)))
    			yValue=0;									// if YValue is within the deadband, don't move
    	else
    			yValue=yValue*throttle;

    	if (joy->GetRawButton(2) == true){
    			// we HAVE pressed for slower speed so go slower
    			yValue = yValue * 0.5;
    		}

    	MotorSpeed = yValue*-1;
    	twistValue = JoyTwist;								// sets twist value of joystick to variable TwistValue

    	// ---- new twist deadband code TEST !! ------
    	double twistOffset = 0.1;	// 10 percent deadband
    	//double twistLimit = 0.5;	// second scall for twist to limit total speed
    	double twistThrottle = throttle;
    	double newTwistValue = twistValue;

    	if(twistValue > 0){
    		newTwistValue -= twistOffset;
    		if (newTwistValue < 0) newTwistValue = 0; }
    	else {
    		newTwistValue += twistOffset;
    		if (newTwistValue > 0) newTwistValue = 0; }
    	newTwistValue *= (twistThrottle + (twistOffset / 2));
    	//newTwistValue *= twistLimit;

    	if (joy->GetRawButton(2) == true){
    		// we have not pressed for faster rotation speed so go slower
    		twistValue = (newTwistValue/TWISTTHROTTLEMOD) * 0.8;
    	} else {
    		// we have pressed for faster rotation speed
    		twistValue = newTwistValue/TWISTTHROTTLEMOD;
    	}

    	MotorAngle = twistValue*-1;

    	double driftComp = 0.2;
    	if(MotorSpeed < 0) driftComp= -0.1;
    	MotorLeft = MotorRight = 0;
    	*/
    }

    public void tankDrive(double leftspeed, double rightspeed) {	
    	// Drive using left and right values
    	robotDrive41.tankDrive(leftspeed,rightspeed);
    }



    
    

}

